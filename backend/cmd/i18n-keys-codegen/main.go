package main

import (
	"context"
	"flag"
	"fmt"
	"io"
	"os"
	"os/signal"
	"path/filepath"
	"slices"
	"sort"
	"strings"

	v "github.com/ARUMANDESU/validation"
	"github.com/BurntSushi/toml"
	"github.com/nicksnyder/go-i18n/v2/i18n"

	"github.com/ARUMANDESU/goread/backend/pkg/errorx"
)

// main <locale dir> <codegen file path>
func main() {
	ctx := context.Background()
	if err := run(ctx, os.Stdout, os.Args); err != nil {
		fmt.Fprintf(os.Stderr, "%s\n", err)
		os.Exit(1)
	}
}

func run(ctx context.Context, w io.Writer, args []string) error {
	const op = errorx.Op("main.run")
	_, cancel := signal.NotifyContext(ctx, os.Interrupt)
	defer cancel()

	var (
		isVerbose  bool
		isDryRun   bool
		localeDir  string
		codegenDir string
	)

	flagset := flag.NewFlagSet("run", flag.PanicOnError)
	flagset.BoolVar(&isVerbose, "v", false, "verbose logs more info")
	flagset.BoolVar(&isDryRun, "dry-run", false, "does not take effect and only logs the output")
	flagset.StringVar(&localeDir, "d", "", "dir path where locales locate")
	flagset.StringVar(&codegenDir, "cgd", "", "dir path where codegen files will be written")

	_ = flagset.Parse(args[1:])

	if isVerbose {
		fmt.Println("[verbose] args")
		fmt.Printf("\tisVerbose: %t\n", isVerbose)
		fmt.Printf("\tisDryRun: %t\n", isDryRun)
		fmt.Printf("\tlocaleDir: %s\n", localeDir)
		fmt.Printf("\tcodegenDir: %s\n", codegenDir)
	}

	err := v.Errors{
		"localeDir":  v.Validate(localeDir, v.Required),
		"codegenDir": v.Validate(codegenDir, v.Required),
	}.Filter()
	if err != nil {
		return op.Wrap(err)
	}

	dirinfo, err := os.ReadDir(localeDir)
	if err != nil {
		return op.WrapMsg(err, "failed to read locale directory")
	}
	if len(dirinfo) == 0 {
		return op.Msgf("no locale files in provided dir: %s", localeDir)
	}
	enLocaleFiles := make(map[string]*i18n.MessageFile)
	if isVerbose {
		fmt.Println("[verbose] files in locale dir")
	}
	for _, d := range dirinfo {
		if isVerbose {
			fmt.Printf("\t%s\n", d.Name())
		}
		if strings.HasSuffix(d.Name(), ".toml") && strings.Contains(d.Name(), "en") {
			enLocaleFiles[d.Name()] = nil
		}
	}
	if len(enLocaleFiles) == 0 {
		return op.Msg("no en locale file are found")
	}

	if isVerbose {
		fmt.Println("[verbose] en locale files")
	}
	for vv := range enLocaleFiles {
		if isVerbose {
			fmt.Printf("\t%s\n", vv)
		}

		filePath := filepath.Join(localeDir, vv)
		fileBytes, err := os.ReadFile(filePath)
		if err != nil {
			return op.WrapMsg(err, "failed to read file")
		}
		msgFile, err := i18n.ParseMessageFileBytes(fileBytes, filePath, map[string]i18n.UnmarshalFunc{"toml": toml.Unmarshal})
		if err != nil {
			return op.WrapMsg(err, "failed to parse i18n toml file")
		}
		enLocaleFiles[vv] = msgFile
	}

	packageName := filepath.Base(codegenDir)
	if isVerbose {
		fmt.Printf("[verbose] package name = %s\n", packageName)
	}
	if isDryRun {
		fmt.Printf("[dry-run] codegen files\n")
	}
	sortedNames := make([]string, 0, len(enLocaleFiles))
	for name := range enLocaleFiles {
		sortedNames = append(sortedNames, name)
	}
	sort.Strings(sortedNames)
	for _, vv := range sortedNames {
		msgFile := enLocaleFiles[vv]
		vv = strings.ReplaceAll(vv, ".", "_")
		vv = strings.ReplaceAll(vv, "_toml", "_gen.go")
		vv = strings.ReplaceAll(vv, "_en", "")
		filePath := filepath.Join(codegenDir, vv)
		if isDryRun {
			fmt.Printf("%s:\n\n", filePath)
		}
		codeGenFile := w
		var file *os.File
		if !isDryRun {
			file, err = os.Create(filePath)
			if err != nil {
				return op.WrapMsgf(err, "failed to open file(%s)", filePath)
			}
			codeGenFile = file
		}
		var keysConstBuilder strings.Builder
		var defaultMsgConstBuilder strings.Builder
		placeholders := make(map[string]struct{})
		slices.SortFunc(msgFile.Messages, func(a, b *i18n.Message) int { return strings.Compare(a.ID, b.ID) })
		for _, msgs := range msgFile.Messages {
			constName := toCamelCase(msgs.ID)
			keysConstBuilder.WriteString(fmt.Sprintf("\t%s = \"%s\"\n", constName, msgs.ID))
			defaultMsgConstBuilder.WriteString(fmt.Sprintf("\t%sMessage = \"%s\"\n", constName, msgs.Other))
			p := getPlaceholders(msgs.Other)
			slices.Sort(p)
			for _, vv := range p {
				placeholders[vv] = struct{}{}
			}
		}

		var placeholdersConstBuilder strings.Builder
		for vv := range placeholders {
			placeholdersConstBuilder.WriteString(fmt.Sprintf("\tPh%s = \"%s\"\n", toCamelCase(vv), vv))
		}

		_, err = fmt.Fprintf(codeGenFile, `// Code generated by cmd/i18n-keys-codegen
// DO NOT EDIT.
package %s

// Keys
const (
%s)

// Default Messages
const (
%s)

// Placeholders
const (
%s)
`, packageName, keysConstBuilder.String(), defaultMsgConstBuilder.String(), placeholdersConstBuilder.String())
		if err != nil {
			return op.WrapMsg(err, "failed to write string into codeGenFile")
		}

		if !isDryRun {
			if err := file.Close(); err != nil {
				return op.WrapMsgf(err, "failed to close file(%s)", filePath)
			}
		}
	}

	return nil
}

func toCamelCase(s string) string {
	n := strings.Builder{}
	n.Grow(len(s))
	capNext := true
	prevIsCap := false
	for i, v := range []byte(s) {
		vIsCap := v >= 'A' && v <= 'Z'
		vIsLow := v >= 'a' && v <= 'z'
		if capNext {
			if vIsLow {
				v += 'A'
				v -= 'a'
			}
		} else if i == 0 {
			if vIsCap {
				v += 'a'
				v -= 'A'
			}
		} else if prevIsCap && vIsCap {
			v += 'a'
			v -= 'A'
		}
		prevIsCap = vIsCap

		if vIsCap || vIsLow {
			n.WriteByte(v)
			capNext = false
		} else if vIsNum := v >= '0' && v <= '9'; vIsNum {
			n.WriteByte(v)
			capNext = true
		} else {
			capNext = v == '_' || v == ' ' || v == '-' || v == '.'
		}
	}
	return n.String()
}

// getPlaceholders parses placeholders from locale message {{.placeholder}}
func getPlaceholders(s string) []string {
	if len(s) < 5 {
		return nil
	}
	var placeholders []string
	var placeholder []byte
	inPlaceholder := false

	for i := 0; i < len(s)-1; i++ {
		if !inPlaceholder && i >= 2 && s[i-2:i+1] == "{{." {
			inPlaceholder = true
			placeholder = placeholder[:0]
			continue
		}
		if inPlaceholder && i < len(s)-1 && s[i:i+2] == "}}" {
			placeholders = append(placeholders, string(placeholder))
			placeholder = placeholder[:0]
			inPlaceholder = false
			i++
			continue
		}
		if inPlaceholder {
			placeholder = append(placeholder, s[i])
		}
	}
	return placeholders
}
